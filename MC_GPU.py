#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HMC sampling (GPU, PyTorch) for a 2D charged colloid–ion system,
using an initial configuration generated by a CPU C/MC code.

Workflow:
  1. Load positions from mc_final.bin (output of mc_cpu_mc_only).
  2. Move the system to GPU (if available).
  3. Run Hamiltonian Monte Carlo (HMC) with:
       - Softened Coulomb interaction
       - Lennard–Jones (12-6) soft-sphere repulsion
       - Fixed colloids, mobile ions
  4. Visualize the HMC trajectory as an animation.

Binary input format (mc_final.bin):
  - float32 array of length N * 2
  - reshape to (N, 2), where N = n_ions + n_cols
  - units are in box coordinates, already wrapped into PBC
"""

import os
import math
import numpy as np
import torch
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# ================== Device Selection ==================
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print("Using device:", device)

# ================== System Parameters ==================
n_ions = 200
n_cols = 2
N = n_ions + n_cols

idx_col1 = n_ions      # index of colloid 1
idx_col2 = n_ions + 1  # index of colloid 2

L_box = 100.0          # box size (square, 2D)
R_col = 10.0           # center–center separation of colloids

# Hard-sphere radii (used to set Lennard-Jones sigma_ij)
r_ion = 1.0
r_col = 1.0

radii_np = np.zeros(N, dtype=np.float32)
radii_np[:n_ions] = r_ion
radii_np[idx_col1:] = r_col
radii = torch.tensor(radii_np, device=device, dtype=torch.float32)

# Charges: half positive, half negative ions, two opposite colloids
q_ion = 1.0
Q_col = 60.0

charge_np = np.zeros(N, dtype=np.float32)
half = n_ions // 2
charge_np[:half] = +q_ion
charge_np[half:n_ions] = -q_ion
charge_np[idx_col1] = +Q_col
charge_np[idx_col2] = -Q_col
charge = torch.tensor(charge_np, device=device, dtype=torch.float32)

# Softened Coulomb interaction parameters
k_c = 20.0
soft_eps = 1.0  # softening length in sqrt(r^2 + soft_eps^2)

# Lennard–Jones parameters for soft-sphere repulsion (HMC only)
# U_LJ(r) = 4 * eps_LJ * [ (sigma / r)^12 - (sigma / r)^6 ]
# with sigma_ij chosen from radii[i] + radii[j].
eps_LJ = 1.0

# ================== Utility: PBC ==================
def minimum_image(rij: torch.Tensor) -> torch.Tensor:
    """Apply the minimum-image convention for 2D periodic boundaries."""
    return rij - torch.round(rij / L_box) * L_box

def wrap_positions(q: torch.Tensor) -> torch.Tensor:
    """Wrap positions into [-L_box/2, L_box/2)."""
    return (q + L_box / 2.0) % L_box - L_box / 2.0

def wrap_positions_numpy(q_np: np.ndarray) -> np.ndarray:
    """Numpy version of wrapping, for initial data."""
    return (q_np + L_box / 2.0) % L_box - L_box / 2.0

# ================== Load Initial Configuration ==================
def load_initial_positions_from_bin(path: str) -> torch.Tensor:
    """
    Load [N, 2] positions from a binary file mc_final.bin.

    Format:
      - float32 array of length N * 2
      - reshaped to (N, 2)
      - units consistent with C code (already wrapped)
    """
    if not os.path.exists(path):
        raise FileNotFoundError(
            f"{path} not found. Please run the C MC code first to generate it."
        )

    data = np.fromfile(path, dtype=np.float32)
    if data.size != N * 2:
        raise ValueError(
            f"Size mismatch in {path}: got {data.size} floats, expected {N * 2}"
        )

    q_np = data.reshape(N, 2)
    q_np = wrap_positions_numpy(q_np)
    q = torch.tensor(q_np, device=device, dtype=torch.float32)
    return q

# ================== Colloid Constraints ==================
def apply_colloid_constraints(q: torch.Tensor) -> torch.Tensor:
    """
    Fix colloid positions at +/- R_col/2 along x-axis, y=0.
    """
    q[idx_col1] = torch.tensor([-R_col / 2.0, 0.0], device=device)
    q[idx_col2] = torch.tensor([+R_col / 2.0, 0.0], device=device)
    return q

# ================== Total Potential: Coulomb + LJ ==================
def total_energy(q: torch.Tensor) -> torch.Tensor:
    """
    Total potential energy:

      U(q) = U_coulomb(q) + U_LJ(q)

    with:
      U_coulomb = sum_{i<j} k_c * q_i q_j / sqrt(r^2 + soft_eps^2)
      U_LJ      = sum_{i<j} 4 eps_LJ [ (sigma_ij / r)^12 - (sigma_ij / r)^6 ]

    where sigma_ij = radii[i] + radii[j].
    """
    U = torch.tensor(0.0, device=device)
    for i in range(N):
        qi = q[i]
        for j in range(i + 1, N):
            rij = minimum_image(qi - q[j])
            r2 = torch.dot(rij, rij) + 1e-12
            r = torch.sqrt(r2)

            # Softened Coulomb
            r_soft = torch.sqrt(r2 + soft_eps**2)
            U = U + k_c * charge[i] * charge[j] / r_soft

            # Lennard–Jones
            sigma_ij = radii[i] + radii[j]
            inv_r2 = (sigma_ij * sigma_ij) / r2      # (sigma/r)^2
            sr6 = inv_r2**3                          # (sigma/r)^6
            sr12 = sr6 * sr6                         # (sigma/r)^12
            U = U + 4.0 * eps_LJ * (sr12 - sr6)

    return U

def grad_total_energy(q: torch.Tensor) -> torch.Tensor:
    """
    Gradient of the total potential U(q) = U_coulomb + U_LJ.

    For each pair (i, j):

      U_coul = k_c * q_i q_j / sqrt(r^2 + soft_eps^2)
        => dU_coul/dr = -k_c q_i q_j / (r_soft^2) * (r / r_soft)

      U_LJ   = 4 eps_LJ [ (sigma/r)^12 - (sigma/r)^6 ]
        => dU_LJ/dr = 24 eps_LJ / r * ( (sigma/r)^6 - 2 (sigma/r)^12 )

    The contribution to the gradient on particle i is:
      grad_i U += dU/dr * (r_ij / r)
    and on particle j is minus this.
    """
    grad = torch.zeros_like(q)

    for i in range(N):
        for j in range(i + 1, N):
            rij = minimum_image(q[i] - q[j])
            r2 = torch.dot(rij, rij) + 1e-12
            r = torch.sqrt(r2)

            # Coulomb part
            r_soft2 = r2 + soft_eps**2
            r_soft = torch.sqrt(r_soft2)
            dU_dr_c = -k_c * charge[i] * charge[j] / r_soft2 * (r / r_soft)
            force_ij_coul = dU_dr_c * (rij / r)

            # Lennard–Jones part
            sigma_ij = radii[i] + radii[j]
            inv_r2 = (sigma_ij * sigma_ij) / r2   # (sigma/r)^2
            sr6 = inv_r2**3                       # (sigma/r)^6
            sr12 = sr6 * sr6                      # (sigma/r)^12
            # dU_LJ/dr = 24 eps_LJ / r * ( (sigma/r)^6 - 2 (sigma/r)^12 )
            dU_dr_LJ = (24.0 * eps_LJ / r) * (sr6 - 2.0 * sr12)
            force_ij_LJ = dU_dr_LJ * (rij / r)

            # Total pairwise contribution (note: this is ∂U/∂q, not minus force)
            force_ij = force_ij_coul + force_ij_LJ

            grad[i] += force_ij
            grad[j] -= force_ij

    # Colloids are fixed: remove their gradients to avoid drift
    grad[idx_col1] = 0.0
    grad[idx_col2] = 0.0

    return grad

# ================== Kinetic Energy & Leapfrog ==================
def kinetic_energy(p: torch.Tensor, m_vec: torch.Tensor) -> torch.Tensor:
    """Kinetic energy: K = sum_i p_i^2 / (2 m_i)."""
    return 0.5 * torch.sum(torch.sum(p * p, dim=1) / m_vec)

def leapfrog_step(q: torch.Tensor,
                  p: torch.Tensor,
                  eps: float,
                  L_steps: int,
                  m_vec: torch.Tensor):
    """
    Perform L leapfrog steps for the HMC proposal trajectory.
    """
    q = q.clone()
    p = p.clone()

    # Initial half-step in p
    gradU = grad_total_energy(q)
    p = p - 0.5 * eps * gradU

    for step in range(L_steps):
        # Full step in q
        q = q + eps * p / m_vec.view(-1, 1)
        q = wrap_positions(q)
        q = apply_colloid_constraints(q)

        # Full step in p (except after the last step)
        if step != L_steps - 1:
            gradU = grad_total_energy(q)
            p = p - eps * gradU

    # Final half-step in p
    gradU = grad_total_energy(q)
    p = p - 0.5 * eps * gradU

    # Momentum flip for reversibility
    p = -p

    # Enforce colloid constraints on momenta
    p[idx_col1] = 0.0
    p[idx_col2] = 0.0

    return q, p

# ================== HMC Parameters ==================
n_hmc_trajectories = 400
hmc_eps = 0.01
hmc_L = 20
beta_hmc = 1.0  # effective inverse temperature for momenta

# Masses: ions light, colloids heavy (effectively fixed)
m_ion = 1.0
m_col = 1e6
m_vec = torch.ones(N, device=device)
m_vec[:n_ions] = m_ion
m_vec[idx_col1:] = m_col

# ================== Main: Load & Run HMC ==================
def main():
    # 1. Load initial configuration from C code output
    q_init = load_initial_positions_from_bin("mc_final.bin")
    q_init = apply_colloid_constraints(wrap_positions(q_init))

    print("Initial configuration loaded from mc_final.bin")

    q = q_init.clone()
    frames = []
    energies = []

    for t in range(n_hmc_trajectories):
        # Sample initial momenta: p ~ N(0, sqrt(m / beta))
        std = torch.sqrt(m_vec / beta_hmc)
        p0 = torch.randn_like(q) * std.view(-1, 1)
        # Colloids have zero momenta
        p0[idx_col1] = 0.0
        p0[idx_col2] = 0.0

        U_old = total_energy(q)
        K_old = kinetic_energy(p0, m_vec)
        H_old = U_old + K_old

        # Propose new state via leapfrog
        q_prop, p_prop = leapfrog_step(q, p0, hmc_eps, hmc_L, m_vec)

        U_new = total_energy(q_prop)
        K_new = kinetic_energy(p_prop, m_vec)
        H_new = U_new + K_new

        dH = (H_new - H_old).item()
        acc_prob = 1.0 if dH <= 0 else math.exp(-dH)

        if torch.rand(1, device=device).item() < acc_prob:
            q = q_prop
            U_use = U_new
        else:
            U_use = U_old

        frames.append(q.detach().cpu().numpy())
        energies.append(U_use.item())

        if (t + 1) % 50 == 0:
            print(f"HMC step {t+1}/{n_hmc_trajectories}, "
                  f"U = {U_use.item():.4f}, dH = {dH:.4e}, acc = {acc_prob:.3f}")

    print("HMC stage finished.")
    print("Final total potential energy (HMC):", energies[-1] if energies else None)

    # 2. Animation
    frames_arr = np.array(frames)
    visualize(frames_arr)

# ================== Visualization ==================
def visualize(frames: np.ndarray):
    """Create a simple 2D animation of ions and colloids in the HMC stage."""
    n_frames = frames.shape[0]

    fig, ax = plt.subplots(figsize=(6, 6))
    ax.set_aspect('equal')
    ax.set_xlim(-L_box / 2, L_box / 2)
    ax.set_ylim(-L_box / 2, L_box / 2)
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_title("HMC sampling (Coulomb + Lennard–Jones)")

    ion_scat = ax.scatter([], [], s=20, c='tab:blue', label='ions')
    col_scat = ax.scatter([], [], s=300, c='tab:red', label='colloids')
    ax.legend(loc='upper right')

    def init():
        ion_scat.set_offsets(np.empty((0, 2)))
        col_scat.set_offsets(np.empty((0, 2)))
        return ion_scat, col_scat

    def update(frame_idx):
        pos = frames[frame_idx]
        ions = pos[:n_ions]
        cols = pos[n_ions:]
        ion_scat.set_offsets(ions)
        col_scat.set_offsets(cols)
        return ion_scat, col_scat

    ani = animation.FuncAnimation(
        fig,
        update,
        frames=n_frames,
        init_func=init,
        interval=30,
        blit=True,
    )

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()
