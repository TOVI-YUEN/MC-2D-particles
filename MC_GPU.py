#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HMC sampling (GPU, PyTorch) for a 2D charged colloid–ion system,
using an initial configuration generated by a CPU C/MC code.

Workflow:
  1. Load positions from mc_final.bin (output of MC.c CPU MC stage).
  2. Move the system to GPU (if available).
  3. Run Hamiltonian Monte Carlo (HMC) with:
       - Softened Coulomb interaction
       - Lennard–Jones (12-6) soft-sphere repulsion
       - Fixed colloids, mobile ions
  4. Visualize the HMC trajectory as an animation.

Binary input format (mc_final.bin):
  - float32 array of length N * 2
  - reshape to (N, 2), where N = n_ions + n_cols
  - units are in box coordinates, already wrapped into PBC
"""

import os
import math
import numpy as np
import torch
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# ================== Device Selection ==================
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print("Using device:", device)

# ================== System Parameters ==================
n_ions = 200
n_cols = 2
N = n_ions + n_cols

idx_col1 = n_ions      # index of colloid 1
idx_col2 = n_ions + 1  # index of colloid 2

L_box = 100.0          # box size (square, 2D)
R_col = 10.0           # center–center separation of colloids

# Hard-sphere radii (used to set Lennard-Jones sigma_ij)
r_ion = 1.0
r_col = 1.0

radii_np = np.zeros(N, dtype=np.float32)
radii_np[:n_ions] = r_ion
radii_np[idx_col1:] = r_col
radii = torch.tensor(radii_np, device=device, dtype=torch.float32)

# Charges: half positive, half negative ions, two opposite colloids
q_ion = 1.0
Q_col = 60.0

charge_np = np.zeros(N, dtype=np.float32)
half = n_ions // 2
charge_np[:half] = +q_ion
charge_np[half:n_ions] = -q_ion
charge_np[idx_col1] = +Q_col
charge_np[idx_col2] = -Q_col
charge = torch.tensor(charge_np, device=device, dtype=torch.float32)

# Softened Coulomb interaction parameters
k_c = 20.0
soft_eps = 1.0  # softening length in sqrt(r^2 + soft_eps^2)

# Lennard–Jones parameters for soft-sphere repulsion (HMC only)
# U_LJ(r) = 4 * eps_LJ * [ (sigma / r)^12 - (sigma / r)^6 ]
# with sigma_ij chosen from radii[i] + radii[j].
eps_LJ = 1.0

# ================== Utility: PBC ==================
def minimum_image(rij: torch.Tensor) -> torch.Tensor:
    """Apply the minimum-image convention for 2D periodic boundaries."""
    return rij - torch.round(rij / L_box) * L_box


def wrap_positions(q: torch.Tensor) -> torch.Tensor:
    """Wrap positions into [-L_box/2, L_box/2)."""
    return (q + L_box / 2.0) % L_box - L_box / 2.0


def wrap_positions_numpy(q_np: np.ndarray) -> np.ndarray:
    """Numpy version of wrapping, for initial data."""
    return (q_np + L_box / 2.0) % L_box - L_box / 2.0


# ================== Load Initial Configuration ==================
def load_initial_positions_from_bin(path: str) -> torch.Tensor:
    """Load [N, 2] positions from a binary file mc_final.bin.

    Format:
      - float32 array of length N * 2
      - reshaped to (N, 2)
      - units consistent with C code (already wrapped)
    """
    if not os.path.exists(path):
        raise FileNotFoundError(
            f"{path} not found. Please run the C MC code first to generate it."
        )

    data = np.fromfile(path, dtype=np.float32)
    if data.size != N * 2:
        raise ValueError(
            f"Size mismatch in {path}: got {data.size} floats, expected {N * 2}"
        )

    q_np = data.reshape(N, 2)
    q_np = wrap_positions_numpy(q_np)
    q = torch.tensor(q_np, device=device, dtype=torch.float32)
    return q


# ================== Colloid Constraints ==================
def apply_colloid_constraints(q: torch.Tensor) -> torch.Tensor:
    """Fix colloid positions at +/- R_col/2 along x-axis, y=0."""
    q[idx_col1] = torch.tensor([-R_col / 2.0, 0.0], device=device)
    q[idx_col2] = torch.tensor([+R_col / 2.0, 0.0], device=device)
    return q


# ================== Total Potential: Coulomb + LJ (vectorized) ==================
def total_energy(q: torch.Tensor) -> torch.Tensor:
    """Vectorized total potential energy: Coulomb + Lennard–Jones.

    U(q) = U_coulomb(q) + U_LJ(q)

    with:
      U_coulomb = sum_{i<j} k_c * q_i q_j / sqrt(r^2 + soft_eps^2)
      U_LJ      = sum_{i<j} 4 eps_LJ [ (sigma_ij / r)^12 - (sigma_ij / r)^6 ]

    where sigma_ij = radii[i] + radii[j].
    """
    # q: (N, 2)
    # pairwise displacement: rij[i,j,:] = q_i - q_j
    rij = q.unsqueeze(1) - q.unsqueeze(0)      # (N, N, 2)
    rij = minimum_image(rij)

    # squared distance
    r2 = torch.sum(rij * rij, dim=-1) + 1e-12  # (N, N)
    Np = q.size(0)
    idx = torch.arange(Np, device=q.device)
    r2[idx, idx] = 1e10                        # avoid self

    r = torch.sqrt(r2)

    # ---------- Coulomb ----------
    r_soft = torch.sqrt(r2 + soft_eps**2)
    qq = charge.view(-1, 1) * charge.view(1, -1)   # (N, N)
    U_coul = k_c * qq / r_soft                     # (N, N)

    # ---------- Lennard–Jones ----------
    sigma_ij = radii.view(-1, 1) + radii.view(1, -1)  # (N, N)
    inv_r2 = (sigma_ij * sigma_ij) / r2               # (sigma/r)^2
    sr6 = inv_r2**3                                   # (sigma/r)^6
    sr12 = sr6 * sr6                                  # (sigma/r)^12
    U_LJ = 4.0 * eps_LJ * (sr12 - sr6)                # (N, N)

    U_pair = U_coul + U_LJ

    # remove diagonal (self-interaction)
    U_pair = U_pair - torch.diag(torch.diag(U_pair))

    # sum over i<j : 0.5 * sum_{i != j}
    U = 0.5 * torch.sum(U_pair)

    return U


def grad_total_energy(q: torch.Tensor) -> torch.Tensor:
    """Vectorized gradient of total potential U(q) = U_coulomb + U_LJ.

    For each pair (i, j):

      U_coul = k_c * q_i q_j / sqrt(r^2 + soft_eps^2)
        => dU_coul/dr = -k_c q_i q_j / (r_soft^2) * (r / r_soft)

      U_LJ   = 4 eps_LJ [ (sigma/r)^12 - (sigma/r)^6 ]
        => dU_LJ/dr = 24 eps_LJ / r * ( (sigma/r)^6 - 2 (sigma/r)^12 )

    We compute all pairwise dU/dr for (i, j) in a vectorized way, then
    convert to Cartesian gradients and sum over j to get grad[i].
    """
    # q: (N, 2)
    Np = q.size(0)

    rij = q.unsqueeze(1) - q.unsqueeze(0)      # (N, N, 2)
    rij = minimum_image(rij)

    r2 = torch.sum(rij * rij, dim=-1) + 1e-12  # (N, N)
    idx = torch.arange(Np, device=q.device)
    r2[idx, idx] = 1e10                        # avoid self

    r = torch.sqrt(r2)

    # ---------- Coulomb dU/dr ----------
    r_soft2 = r2 + soft_eps**2
    r_soft = torch.sqrt(r_soft2)
    qq = charge.view(-1, 1) * charge.view(1, -1)         # (N, N)
    dU_dr_c = -k_c * qq / r_soft2 * (r / r_soft)         # (N, N)

    # ---------- Lennard–Jones dU/dr ----------
    sigma_ij = radii.view(-1, 1) + radii.view(1, -1)     # (N, N)
    inv_r2 = (sigma_ij * sigma_ij) / r2
    sr6 = inv_r2**3
    sr12 = sr6 * sr6
    dU_dr_LJ = (24.0 * eps_LJ / r) * (sr6 - 2.0 * sr12)  # (N, N)

    # total radial derivative
    dU_dr = dU_dr_c + dU_dr_LJ
    dU_dr[idx, idx] = 0.0

    # unit vectors n_ij = rij / r
    n_ij = rij / r.unsqueeze(-1)                         # (N, N, 2)

    # F_ij_on_i = dU/dr * n_ij (this is ∂U/∂q_i contribution from pair (i,j))
    F_ij = dU_dr.unsqueeze(-1) * n_ij                    # (N, N, 2)

    # gradient on particle i: sum over all j
    grad = torch.sum(F_ij, dim=1)                        # (N, 2)

    # colloids are fixed → zero their gradients
    grad[idx_col1] = 0.0
    grad[idx_col2] = 0.0

    return grad


# ================== Kinetic Energy & Leapfrog ==================
def kinetic_energy(p: torch.Tensor, m_vec: torch.Tensor) -> torch.Tensor:
    """Kinetic energy: K = sum_i p_i^2 / (2 m_i)."""
    return 0.5 * torch.sum(torch.sum(p * p, dim=1) / m_vec)


def leapfrog_step(q: torch.Tensor,
                  p: torch.Tensor,
                  eps: float,
                  L_steps: int,
                  m_vec: torch.Tensor):
    """Perform L leapfrog steps for the HMC proposal trajectory."""
    q = q.clone()
    p = p.clone()

    # Initial half-step in p
    gradU = grad_total_energy(q)
    p = p - 0.5 * eps * gradU

    for step in range(L_steps):
        # Full step in q
        q = q + eps * p / m_vec.view(-1, 1)
        q = wrap_positions(q)
        q = apply_colloid_constraints(q)

        # Full step in p (except after the last step)
        if step != L_steps - 1:
            gradU = grad_total_energy(q)
            p = p - eps * gradU

    # Final half-step in p
    gradU = grad_total_energy(q)
    p = p - 0.5 * eps * gradU

    # Momentum flip for reversibility
    p = -p

    # Enforce colloid constraints on momenta
    p[idx_col1] = 0.0
    p[idx_col2] = 0.0

    return q, p


# ================== HMC Parameters ==================
n_hmc_trajectories = 400
hmc_eps = 0.01
hmc_L = 20
beta_hmc = 1.0  # effective inverse temperature for momenta

# Masses: ions light, colloids heavy (effectively fixed)
m_ion = 1.0
m_col = 1e6
m_vec = torch.ones(N, device=device)
m_vec[:n_ions] = m_ion
m_vec[idx_col1:] = m_col


# ================== Main: Load & Run HMC ==================
def main():
    # 1. Load initial configuration from C code output
    q_init = load_initial_positions_from_bin("mc_final.bin")
    q_init = apply_colloid_constraints(wrap_positions(q_init))

    print("Initial configuration loaded from mc_final.bin")

    q = q_init.clone()
    frames = []
    energies = []

    for t in range(n_hmc_trajectories):
        # Sample initial momenta: p ~ N(0, sqrt(m / beta))
        std = torch.sqrt(m_vec / beta_hmc)
        p0 = torch.randn_like(q) * std.view(-1, 1)
        # Colloids have zero momenta
        p0[idx_col1] = 0.0
        p0[idx_col2] = 0.0

        U_old = total_energy(q)
        K_old = kinetic_energy(p0, m_vec)
        H_old = U_old + K_old

        # Propose new state via leapfrog
        q_prop, p_prop = leapfrog_step(q, p0, hmc_eps, hmc_L, m_vec)

        U_new = total_energy(q_prop)
        K_new = kinetic_energy(p_prop, m_vec)
        H_new = U_new + K_new

        dH = (H_new - H_old).item()
        acc_prob = 1.0 if dH <= 0 else math.exp(-dH)

        if torch.rand(1, device=device).item() < acc_prob:
            q = q_prop
            U_use = U_new
        else:
            U_use = U_old

        frames.append(q.detach().cpu().numpy())
        energies.append(U_use.item())

        if (t + 1) % 50 == 0:
            print(
                f"HMC step {t+1}/{n_hmc_trajectories}, "
                f"U = {U_use.item():.4f}, dH = {dH:.4e}, acc = {acc_prob:.3f}"
            )

    print("HMC stage finished.")
    print("Final total potential energy (HMC):", energies[-1] if energies else None)

    # 2. Animation
    frames_arr = np.array(frames)
    visualize(frames_arr)


# ================== Visualization ==================
def visualize(frames: np.ndarray):
    """Create a simple 2D animation of ions and colloids in the HMC stage."""
    n_frames = frames.shape[0]

    fig, ax = plt.subplots(figsize=(6, 6))
    ax.set_aspect('equal')
    ax.set_xlim(-L_box / 2, L_box / 2)
    ax.set_ylim(-L_box / 2, L_box / 2)
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_title("HMC sampling (Coulomb + Lennard–Jones, vectorized)")

    ion_scat = ax.scatter([], [], s=20, c='tab:blue', label='ions')
    col_scat = ax.scatter([], [], s=300, c='tab:red', label='colloids')
    ax.legend(loc='upper right')

    def init():
        ion_scat.set_offsets(np.empty((0, 2)))
        col_scat.set_offsets(np.empty((0, 2)))
        return ion_scat, col_scat

    def update(frame_idx):
        pos = frames[frame_idx]
        ions = pos[:n_ions]
        cols = pos[n_ions:]
        ion_scat.set_offsets(ions)
        col_scat.set_offsets(cols)
        return ion_scat, col_scat

    
    ani = animation.FuncAnimation(
        fig,
        update,
        frames=n_frames,
        init_func=init,
        interval=30,
        blit=True,
    )

    plt.tight_layout()
    plt.show()




if __name__ == "__main__":
    main()
